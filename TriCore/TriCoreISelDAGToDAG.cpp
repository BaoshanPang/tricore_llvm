//===-- TriCoreISelDAGToDAG.cpp - A dag to dag inst selector for TriCore --===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the TriCore target.
//
//===----------------------------------------------------------------------===//

#include "TriCore.h"
#include "TriCoreTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

#include "TriCoreInstrInfo.h"

#define DEBUG_TYPE "tricore-isel"

using namespace llvm;

/// TriCoreDAGToDAGISel - TriCore specific code to select TriCore machine
/// instructions for SelectionDAG operations.
///
namespace {
class TriCoreDAGToDAGISel : public SelectionDAGISel {
  const TriCoreSubtarget &Subtarget;

public:
  explicit TriCoreDAGToDAGISel(TriCoreTargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel), Subtarget(*TM.getSubtargetImpl()) {}

  SDNode *Select(SDNode *N);

  bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);

  virtual const char *getPassName() const {
    return "TriCore DAG->DAG Pattern Instruction Selection";
  }

private:
  SDNode *SelectMoveImmediate(SDNode *N);
  SDNode *SelectConditionalBranch(SDNode *N,uint64_t code);
  SDNode *SelectBRCC(SDNode* N);

// Include the pieces autogenerated from the target description.
#include "TriCoreGenDAGISel.inc"
};
} // end anonymous namespace

bool TriCoreDAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset) {
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
//    EVT PtrVT = getTargetLowering()->getPointerTy(*TM.getDataLayout());
    EVT PtrVT = getTargetLowering()->getPointerTy(CurDAG->getDataLayout());
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), PtrVT);
    Offset = CurDAG->getTargetConstant(0, Addr, MVT::i32);
//    outs().changeColor(raw_ostream::RED)<<"Selecting Frame!\n";
//    outs().changeColor(raw_ostream::WHITE);
    return true;
  }
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress ||
      Addr.getOpcode() == ISD::TargetGlobalTLSAddress) {
    return false; // direct calls.
  }

  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, Addr, MVT::i32);
  return true;
}

SDNode *TriCoreDAGToDAGISel::SelectMoveImmediate(SDNode *N) {
  // Make sure the immediate size is supported.
  ConstantSDNode *ConstVal = cast<ConstantSDNode>(N);
  uint64_t ImmVal = ConstVal->getZExtValue();
  outs() <<"ImmVal: "<<  ImmVal << "\n";

//  SDValue tmp = N->getOperand(1);
//  const ConstantSDNode * tmpC = dyn_cast<ConstantSDNode>(tmp);
//  uint64_t tmpVal = tmpC->getZExtValue();
//  outs() <<"tmpVal: "<<  tmpVal << "\n";

  uint64_t SupportedMask = 0xfffffffff;
  if ((ImmVal & SupportedMask) != ImmVal) {
  	outs() <<" Immediate size not supported!\n";
    return SelectCode(N);
  }

  // Select the low part of the immediate move.
  uint64_t LoMask = 0xffff;
  uint64_t HiMask = 0xffff0000;
  uint64_t ImmLo = (ImmVal & LoMask);
  uint64_t ImmHi = (ImmVal & HiMask);
  SDValue ConstLo = CurDAG->getTargetConstant(ImmLo, N, MVT::i32);
  SDValue ImmValNode = CurDAG->getTargetConstant(ImmVal, N, MVT::i32);
  MachineSDNode *Move;
  if(ImmVal < 65535) {
  	Move =
  			CurDAG->getMachineNode(TriCore::MOVrlc, N, MVT::i32, ConstLo); //MOVLOi16
  }
  // Select the high part of the immediate move, if needed.
  if (ImmHi) {
	outs() <<"Select the high part\n";
//	SDValue *x = new SDValue(Move, 0);
//
//	outs()<< "operands: " << x->getNumOperands() <<"\n";
//	outs()<< "operands: " << x->getNode() <<"\n";
    SDValue ConstHi = CurDAG->getTargetConstant(ImmHi >> 16, N, MVT::i32);
    outs()<< "ImmHi: " << ImmHi <<"\n";
    outs()<< "ImmHi >> 16: " << (ImmHi >> 16) <<"\n";
    outs()<< "ImmLo: " << ImmLo <<"\n";
    MachineSDNode *MoveHi;
    //MoveHi = CurDAG->getMachineNode(TriCore::MOVHIi16, N, MVT::i32, ConstHi);
		//Move = CurDAG->getMachineNode(TriCore::ADDi, N, MVT::i32, SDValue(MoveHi, 0),
		//																ConstLo);
		Move = CurDAG->getMachineNode(TriCore::MOVi32, N, MVT::i32, ImmValNode);
    outs()<< Move <<"\n";
  }

  	return Move;
}

static StringRef printCondCode(ISD::CondCode e) {

	switch(e){
	default: return "unknown";
	case ISD::SETEQ: return "SETEQ";
	case ISD::SETGT: return "SETGT";
	case ISD::SETGE: return "SETGE";
	case ISD::SETLT: return "SETLT";
	case ISD::SETLE: return "SETLE";
	case ISD::SETNE: return "SETNE";
	case ISD::SETTRUE2: return "SETTRUE2";
	}
}


SDNode *TriCoreDAGToDAGISel::SelectConditionalBranch(SDNode *N, uint64_t code) {

//	SDValue Chain = N->getOperand(0);
	SDValue Cond = N->getOperand(1);
	SDValue LHS = N->getOperand(3);
	SDValue RHS = N->getOperand(4);
	SDValue Target = N->getOperand(2);

	uint64_t realCond;
	unsigned opCode;
	bool isSExt4= false;
	ConstantSDNode *Ccode= cast<ConstantSDNode>(Cond);
	uint64_t CVal = Ccode->getZExtValue();

	if (const ConstantSDNode *RHSConst = dyn_cast<ConstantSDNode>(RHS) ){
		outs() << "This is working\n";
		outs() <<"Value of RHS: " << RHSConst->getSExtValue() <<"\n";
		isSExt4 = (isInt<4>(RHSConst->getSExtValue())) ? true:false;
		if(isSExt4)
			RHS = CurDAG->getTargetConstant(RHSConst->getSExtValue(), N, MVT::i32);
	}

	switch(CVal) {

		case ISD::SETLT:
				realCond=ISD::SETLT;
				opCode = (isSExt4==true) ? TriCore::JLTbrc : TriCore::JLTbrr;
				break;
		case ISD::SETGE:
				realCond=ISD::SETGE;
				opCode = (isSExt4==true) ? TriCore::JGEbrc : TriCore::JGEbrr;
				break;
		case ISD::SETGT:
				std::swap(LHS,RHS);
				realCond=ISD::SETLT;
				opCode = TriCore::JLTbrr;
				break;
		case ISD::SETLE:
				std::swap(LHS,RHS);
				realCond=ISD::SETGE;
				opCode = TriCore::JGEbrr;
				break;
		case ISD::SETEQ:
				realCond=ISD::SETEQ;
				opCode = TriCore::JEQbrr;
				break;
		case ISD::SETNE:
				realCond=ISD::SETNE;
				opCode = TriCore::JNEbrr;
				break;


	}


	outs().changeColor(raw_ostream::BLUE,1);
	Cond.dump();
	LHS.dump();
	RHS.dump();
	outs().changeColor(raw_ostream::WHITE,0);


	outs()<<"Generate a branch instruction.\n";
	//ISD::CondCode CC = cast<CondCodeSDNode>(N->getOperand(1))->get();
//	outs().changeColor(raw_ostream::GREEN,1)<<printCondCode(CC) <<"\n";
	outs().changeColor(raw_ostream::WHITE,0);
	SDValue CCVal = CurDAG->getTargetConstant(realCond, N, MVT::i32);
//	CCVal.dump();
	SDValue BranchOps[] = {CCVal,  Target, LHS, RHS };
//
	EVT CompareTys[] = { MVT::i32 };
	SDVTList CompareVT = CurDAG->getVTList(CompareTys);


	//if(code == ISD::SETGT) {
		return CurDAG->getMachineNode(opCode, N, MVT::Other, BranchOps);

	//}



	//return N;



}

SDNode *TriCoreDAGToDAGISel::SelectBRCC(SDNode* N) {

	SDValue Chain = N->getOperand(0);
	SDValue Cond = N->getOperand(1);
	SDValue LHS = N->getOperand(2);
	SDValue RHS = N->getOperand(3);
	SDValue Target = N->getOperand(4);





}


SDNode *TriCoreDAGToDAGISel::Select(SDNode *N) {

	SDLoc dl(N);

  // Dump information about the Node being selected
  DEBUG(errs().changeColor(raw_ostream::GREEN) << "Selecting: ");
  DEBUG(N->dump(CurDAG));
  DEBUG(errs() << "\n");

  switch (N->getOpcode()) {
  case ISD::Constant:
    return SelectMoveImmediate(N);
//  case ISD::STORE:
//  	outs().changeColor(raw_ostream::GREEN) << "This is a store!\n";
//  	outs().changeColor(raw_ostream::WHITE);
//  	break;
//  case ISD::BR_CC:
//  	return SelectConditionalBranch(N);
  case ISD::FrameIndex: {
   	//FrameIndexSDNode *FSDNode = cast<FrameIndexSDNode>(N);
  	int FI = cast<FrameIndexSDNode>(N)->getIndex();
  	SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i32);
  	if (N->hasOneUse()) {

  	    	return CurDAG->SelectNodeTo(N, TriCore::ADDri, MVT::i32, TFI,
  																			CurDAG->getTargetConstant(0, dl, MVT::i32));

  	    }
  	return CurDAG->getMachineNode(TriCore::ADDri, dl, MVT::i32, TFI,
																CurDAG->getTargetConstant(0, dl, MVT::i32));
  	}
//  case ISD::LOAD:
//  	outs().changeColor(raw_ostream::BLUE,1) <<"This is a load\n";
//  	outs().changeColor(raw_ostream::WHITE,0);
//  	break;
  case ISD::ADDC:
  	outs().changeColor(raw_ostream::BLUE,1) <<"This is a ADDC\n";
		outs().changeColor(raw_ostream::WHITE,0);

		break;
  case ISD::ADD:
    	outs().changeColor(raw_ostream::BLUE,1) <<"This is a ADD\n";
  		outs().changeColor(raw_ostream::WHITE,0);

  		break;
  case TriCoreISD::BR_CC:

  	SDValue op1 = N->getOperand(0);
  	SDValue op2 = N->getOperand(1);

  	ConstantSDNode *op4 = cast<ConstantSDNode>(op2);
  	//CondCodeSDNode *op9 = cast<CondCodeSDNode>(op2);

  	outs().changeColor(raw_ostream::BLUE,1) <<"This is a BR_CC\n";
  	//op1.dump();
  	//op2.dump();
  	//op4->dump();
  	//outs() << printCondCode(op9->get()) <<"\n";
		outs().changeColor(raw_ostream::WHITE,0);
  	return SelectConditionalBranch(N, op4->getZExtValue());




  	break;


  }

  SDNode *ResNode = SelectCode(N);

	DEBUG(errs() << "=> ");
	if (ResNode == nullptr || ResNode == N)
		DEBUG(N->dump(CurDAG));
	else
		DEBUG(ResNode->dump(CurDAG));
	DEBUG(errs() << "\n");
  return ResNode;
}
/// createTriCoreISelDag - This pass converts a legalized DAG into a
/// TriCore-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createTriCoreISelDag(TriCoreTargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new TriCoreDAGToDAGISel(TM, OptLevel);
}
